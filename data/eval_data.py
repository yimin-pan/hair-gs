"""
Class for loading different evaluation data into common format to compute metrics.
GT is loaded from a npz file which is generated by hair_data.py, while the others comes from the output of different reconstruction methods.
Currently supporting:
 - GS (ours)
 - Strand Integration: https://github.com/elerac/strand_integration
 - Neural Haircut: https://github.com/egorzakharov/NeuralHaircut
"""

from typing import NamedTuple

import numpy as np
from plyfile import PlyData


class HairEvalData(NamedTuple):
    points: np.ndarray  # (N, 3) the points (joints) of the strands
    directions: np.ndarray  # (N, 3) the direction corresponding to each point
    points_id_to_strand_id: np.ndarray  # mapping from points idx to strand idx
    edges: np.ndarray


def load_hair_eval_data_npz(path: str) -> HairEvalData:
    data = np.load(path)
    points = data["points"]
    directions = data["directions"]
    directions /= np.linalg.norm(directions, axis=1, keepdims=True)
    points_id_to_strand_id = data["points_id_to_strand_id"]
    edges = data["edges"]
    return HairEvalData(
        points=points,
        directions=directions,
        points_id_to_strand_id=points_id_to_strand_id,
        edges=edges,
    )


def load_eval_data_from_strand_integration_output(path: str) -> HairEvalData:
    plydata = PlyData.read(path)
    assert (
        len(plydata.elements) == 1 or len(plydata.elements) == 4
    ), "Expected only 1 or 4 element in the ply file"
    points_id_to_strand_id = None
    edges = None
    element = plydata.elements[0]
    points = np.stack(
        (np.asarray(element["x"]), np.asarray(element["y"]), np.asarray(element["z"])),
        axis=1,
    )
    # normalized 3d direction stored in normal
    directions = np.stack(
        (
            np.asarray(element["nx"]),
            np.asarray(element["ny"]),
            np.asarray(element["nz"]),
        ),
        axis=1,
    )
    directions /= np.linalg.norm(directions, axis=1, keepdims=True)
    if len(plydata.elements) == 4:
        element = plydata.elements[1]
        strand_roots = np.stack(
            (
                np.asarray(element["x"]),
                np.asarray(element["y"]),
                np.asarray(element["z"]),
            ),
            axis=1,
        )
        strand_roots /= 100
        element = plydata.elements[2]
        points_id_to_strand_id = np.asarray(element["points_id_to_strand_id"])
        element = plydata.elements[3]
        edges = np.stack(
            (np.asarray(element["vertex1"]), np.asarray(element["vertex2"])), axis=1
        )
    return HairEvalData(
        points=points,
        directions=directions,
        points_id_to_strand_id=points_id_to_strand_id,
        edges=edges,
    )


def load_eval_data_from_neural_haircut_output(
    path: str, num_points_per_strand: float = 100
) -> HairEvalData:
    import pyvista as pv

    points = pv.read(path).points
    points = np.array(points)
    strands = points.reshape(-1, num_points_per_strand, 3)
    num_strands = strands.shape[0]
    num_final_eval_points = num_strands * (num_points_per_strand - 1)
    directions = (strands[:, 1:] - strands[:, :-1]).reshape(num_final_eval_points, 3)
    directions /= np.linalg.norm(directions, axis=1, keepdims=True)
    points = strands[:, :-1].reshape(num_final_eval_points, 3)
    points_id_to_strand_id = np.repeat(
        np.arange(num_strands), num_points_per_strand - 1
    )
    edges = []  # (N, 2)
    for i in range(num_strands):
        offset = i * (num_points_per_strand - 1)
        strand_edge = np.stack(
            (
                np.arange(num_points_per_strand - 2) + offset,
                np.arange(num_points_per_strand - 2) + offset + 1,
            ),
            axis=1,
        )
        edges.append(strand_edge)
    edges = np.concatenate(edges, axis=0)
    return HairEvalData(
        points=points,
        directions=directions,
        points_id_to_strand_id=points_id_to_strand_id,
        edges=edges,
    )


def compute_eval_data_from_gs(gs) -> HairEvalData:
    mask = gs.compute_foreground_mask().cpu().numpy()
    points = gs.get_xyz.detach().cpu().numpy()[mask]
    directions = gs.get_orientation.detach().cpu().numpy()[mask]
    return HairEvalData(
        points=points,
        directions=directions,
        points_id_to_strand_id=None,
        edges=None,
    )


def compute_eval_data_from_hair_gs(
    hair_gs, compute_edges: bool = False, only_foreground: bool = False
) -> HairEvalData:
    endpoints = hair_gs._endpoints.detach().cpu().numpy()
    segments_id = np.concatenate(hair_gs.strands_info.list_strands, axis=0)

    # This filtering is not necessary if compute_strands_info was called with only_foreground=True
    if only_foreground:
        mask = hair_gs.compute_foreground_mask().cpu().numpy()
        endpoint_pairs = hair_gs.endpoint_pairs.cpu().numpy()
        endpoint_pairs = endpoint_pairs[mask]
        line_segment_points_id = endpoint_pairs.flatten()
        line_mask = np.any(np.isin(segments_id, line_segment_points_id), axis=1)
        segments_id = segments_id[line_mask]

    segments = endpoints[segments_id]
    directions = segments[:, 1] - segments[:, 0]
    directions /= np.linalg.norm(directions, axis=1, keepdims=True)
    points_id = segments_id[:, 0]
    points = endpoints[points_id]
    point_id_to_strand_id = hair_gs.strands_info.id_to_strand_id[points_id]
    # edges need extra computation, only compute while converting to visualizable ply
    edges = None
    if compute_edges:
        # mapping of indices to new set of points
        mapping = np.zeros(segments_id.max() + 1, dtype=np.int32)
        mapping[segments_id[:, 0]] = np.arange(segments_id.shape[0])
        # exclude single segment strands
        u, c = np.unique(segments_id, return_counts=True)
        u = u[c > 1]
        mask = np.isin(segments_id[:, 1], u)
        segments_id = segments_id[mask]
        edges = mapping[segments_id]
    return HairEvalData(
        points=points,
        directions=directions,
        points_id_to_strand_id=point_id_to_strand_id,
        edges=edges,
    )


def load_eval_data_from_gaussians(path: str, sh_degree: int = 0) -> HairEvalData:
    from scene.hair_gaussian_model import GaussianModel, HairGaussianModel

    plydata = PlyData.read(path)
    if len(plydata.elements) == 1:
        gs = GaussianModel(sh_degree)
        gs.load_ply(path)
        eval_data = compute_eval_data_from_gs(gs)
    else:
        gs = HairGaussianModel(sh_degree)
        gs.load_ply(path)
        eval_data = compute_eval_data_from_hair_gs(gs, compute_edges=True)
    return eval_data


eval_data_loading_callbacks = {
    "gt": load_hair_eval_data_npz,
    "strand_integration": load_eval_data_from_strand_integration_output,
    "neural_haircut": load_eval_data_from_neural_haircut_output,
    "gs": load_eval_data_from_gaussians,
}
